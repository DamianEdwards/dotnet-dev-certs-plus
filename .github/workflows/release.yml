name: Release

on:
  workflow_dispatch:

env:
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  release:
    runs-on: ubuntu-latest

    environment: nuget.org

    permissions:
      contents: write
      id-token: write
      actions: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Get version state and CI run
        id: version
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e

          # Get dev release body
          DEV_RELEASE_BODY=$(gh release view dev --json body --jq '.body // empty' 2>/dev/null || echo "")

          if [ -z "$DEV_RELEASE_BODY" ]; then
            echo "::error::No dev release found. Run CI first to create a dev build."
            exit 1
          fi

          # Parse state
          STATE_JSON=$(dotnet scripts/version.cs -- state --body "$DEV_RELEASE_BODY")
          echo "Current state: $STATE_JSON"

          # Check for pending release
          PENDING=$(echo "$STATE_JSON" | jq -r '.pending')
          if [ "$PENDING" != "none" ]; then
            echo "::error::A release is already pending ($PENDING). Complete or cancel it first."
            exit 1
          fi

          # Get CI run ID from dev release
          CI_RUN_ID=$(echo "$DEV_RELEASE_BODY" | grep -o '<!-- CI_RUN_ID: [^>]* -->' | sed 's/<!-- CI_RUN_ID: \(.*\) -->/\1/' || echo "")

          if [ -z "$CI_RUN_ID" ]; then
            echo "No CI run ID in dev release, finding latest successful CI run..."
            CI_RUN_ID=$(gh run list --workflow=ci.yml --branch=main --status=success --limit=1 --json databaseId --jq '.[0].databaseId // empty')
            if [ -z "$CI_RUN_ID" ]; then
              echo "::error::No successful CI run found. Run CI first."
              exit 1
            fi
          fi

          echo "CI run ID: $CI_RUN_ID"

          # Get RC version from dev release
          RC_VERSION=$(echo "$DEV_RELEASE_BODY" | grep -o '<!-- RC_VERSION: [^>]* -->' | sed 's/<!-- RC_VERSION: \(.*\) -->/\1/' || echo "")

          if [ -z "$RC_VERSION" ]; then
            # Calculate from state
            VERSIONS_JSON=$(dotnet scripts/version.cs -- calculate --state "$STATE_JSON")
            RC_VERSION=$(echo "$VERSIONS_JSON" | jq -r '.rcVersion')
          fi

          echo "RC version to ship: $RC_VERSION"

          # Determine if this is a prerelease or stable
          PHASE=$(echo "$STATE_JSON" | jq -r '.phase')
          if [ "$PHASE" = "rtm" ]; then
            IS_PRERELEASE="false"
          else
            IS_PRERELEASE="true"
          fi

          # Output (compact JSON to single line for GITHUB_OUTPUT)
          STATE_JSON_COMPACT=$(echo "$STATE_JSON" | jq -c '.')
          echo "version=${RC_VERSION}" >> $GITHUB_OUTPUT
          echo "ci_run_id=${CI_RUN_ID}" >> $GITHUB_OUTPUT
          echo "state_json=${STATE_JSON_COMPACT}" >> $GITHUB_OUTPUT
          echo "is_prerelease=${IS_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "phase=${PHASE}" >> $GITHUB_OUTPUT

          # Summary
          echo "## Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${RC_VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- **Phase:** ${PHASE}" >> $GITHUB_STEP_SUMMARY
          echo "- **Is Prerelease:** ${IS_PRERELEASE}" >> $GITHUB_STEP_SUMMARY
          echo "- **CI Run:** ${CI_RUN_ID}" >> $GITHUB_STEP_SUMMARY

      - name: Download RC package from CI run
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CI_RUN_ID="${{ steps.version.outputs.ci_run_id }}"
          echo "Downloading package-rc artifact from CI run $CI_RUN_ID..."

          mkdir -p ./artifacts
          gh run download "$CI_RUN_ID" --name package-rc --dir ./artifacts

          if [ ! -f ./artifacts/*.nupkg ]; then
            echo "::error::Failed to download RC package artifact from CI run $CI_RUN_ID"
            exit 1
          fi

          echo "Downloaded package:"
          ls -la ./artifacts/

      - name: Verify package version
        run: |
          EXPECTED_VERSION="${{ steps.version.outputs.version }}"
          PACKAGE_FILE=$(ls ./artifacts/*.nupkg | head -1)
          PACKAGE_NAME=$(basename "$PACKAGE_FILE")

          echo "Expected version: $EXPECTED_VERSION"
          echo "Package file: $PACKAGE_NAME"

          # Extract version from package filename
          PACKAGE_VERSION=$(echo "$PACKAGE_NAME" | sed 's/dotnet-dev-certs-plus\.\(.*\)\.nupkg/\1/')
          echo "Package version: $PACKAGE_VERSION"

          if [ "$PACKAGE_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "::error::Package version mismatch! Expected '$EXPECTED_VERSION' but package has '$PACKAGE_VERSION'"
            echo "This can happen if the version state was modified after the last CI run."
            echo "Please run CI again or use Bump Version workflow."
            exit 1
          fi

          echo "âœ“ Package version matches expected version"

      - name: NuGet login (trusted publishing)
        uses: nuget/login@v1
        id: nuget-login
        with:
          user: DamianEdwards

      - name: Push to NuGet.org
        run: |
          dotnet nuget push ./artifacts/*.nupkg \
            --source "https://api.nuget.org/v3/index.json" \
            --api-key ${{ steps.nuget-login.outputs.NUGET_API_KEY }} \
            --skip-duplicate

      - name: Create GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"

          # Skip if release already exists
          if gh release view "v${VERSION}" --repo ${{ github.repository }} &>/dev/null; then
            echo "Release v${VERSION} already exists, skipping creation"
          else
            PRERELEASE_FLAG=""
            if [ "$IS_PRERELEASE" = "true" ]; then
              PRERELEASE_FLAG="--prerelease"
              NOTES="## dotnet-dev-certs-plus ${VERSION}

          This is a **pre-release** version.

          ### Installation

          \`\`\`bash
          dotnet tool install --global dotnet-dev-certs-plus --version ${VERSION}
          \`\`\`

          ### Package

          - [NuGet.org](https://www.nuget.org/packages/dotnet-dev-certs-plus/${VERSION})"
            else
              NOTES="## dotnet-dev-certs-plus v${VERSION}

          ### Installation

          \`\`\`bash
          dotnet tool install --global dotnet-dev-certs-plus
          \`\`\`

          Or update an existing installation:

          \`\`\`bash
          dotnet tool update --global dotnet-dev-certs-plus
          \`\`\`

          ### Package

          - [NuGet.org](https://www.nuget.org/packages/dotnet-dev-certs-plus/${VERSION})"
            fi

            gh release create "v${VERSION}" \
              --repo ${{ github.repository }} \
              $PRERELEASE_FLAG \
              --title "v${VERSION}" \
              --notes "$NOTES" \
              ./artifacts/*.nupkg
          fi

      - name: Advance version state
        env:
          GH_TOKEN: ${{ github.token }}
          STATE_JSON: ${{ steps.version.outputs.state_json }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          echo "Advancing version state after shipping $VERSION"
          echo "Current state: $STATE_JSON"

          # Calculate next state
          NEW_STATE_JSON=$(dotnet scripts/version.cs -- advance --state "$STATE_JSON" --shipped-version "$VERSION")
          echo "New state: $NEW_STATE_JSON"

          # Calculate next versions
          VERSIONS_JSON=$(dotnet scripts/version.cs -- calculate --state "$NEW_STATE_JSON")
          NEXT_DEV_VERSION=$(echo "$VERSIONS_JSON" | jq -r '.devVersion')
          NEXT_RC_VERSION=$(echo "$VERSIONS_JSON" | jq -r '.rcVersion')
          NEXT_STATE=$(echo "$VERSIONS_JSON" | jq -r '.nextState')

          echo "Next dev version: $NEXT_DEV_VERSION"
          echo "Next RC version: $NEXT_RC_VERSION"

          # Delete existing dev release
          if gh release view dev --json isDraft &>/dev/null; then
            gh release delete dev --yes
          fi

          # Create new dev draft release with advanced state
          # Note: We use NEXT_STATE with devNumber=0 since no build has happened yet
          NEW_BASE=$(echo "$NEW_STATE_JSON" | jq -r '.base')
          NEW_PHASE=$(echo "$NEW_STATE_JSON" | jq -r '.phase')
          NEW_PHASE_NUMBER=$(echo "$NEW_STATE_JSON" | jq -r '.phaseNumber')
          STATE_STRING="${NEW_BASE}|${NEW_PHASE}|${NEW_PHASE_NUMBER}|0|none"

          gh release create dev \
            --draft \
            --prerelease \
            --title "Development Build" \
            --notes "## Development Build

          **Last Published Release:** v${VERSION}
          **Next Dev Version:** ${NEXT_DEV_VERSION}
          **Next RC Version:** ${NEXT_RC_VERSION}
          **Commit:** ${{ github.sha }}
          **Build:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          Release shipped successfully. Next dev build will be available after the next push to main.

          <!-- VERSION_STATE: ${STATE_STRING} -->
          "
