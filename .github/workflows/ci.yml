name: CI

on:
  push:
    branches: [main]
    paths-ignore:
      - '**/*.md'

env:
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      packages: write
      checks: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate version
        id: version
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e

          # Initialize defaults
          MAJOR=0
          MINOR=0
          PATCH=1
          STAGE="pre"
          PRE_NUMBER=1
          DEV_NUMBER=0
          PENDING_RELEASE="none"

          # Try to read state from dev draft release body
          DEV_RELEASE_BODY=$(gh release view dev --json body --jq '.body // empty' 2>/dev/null || echo "")

          if [ -n "$DEV_RELEASE_BODY" ]; then
            # Parse version state from release body (stored as HTML comments)
            # Format: <!-- VERSION_STATE: major.minor.patch|stage|pre_number|dev_number|pending_release -->
            STATE_LINE=$(echo "$DEV_RELEASE_BODY" | grep -o '<!-- VERSION_STATE: [^>]* -->' | head -1 || echo "")
            if [ -n "$STATE_LINE" ]; then
              STATE_DATA=$(echo "$STATE_LINE" | sed 's/<!-- VERSION_STATE: \(.*\) -->/\1/')
              # Read all 5 fields (pending_release may be missing in old state)
              IFS='|' read -r BASE_VER STAGE PRE_NUMBER DEV_NUMBER PENDING_RELEASE <<< "$STATE_DATA"
              IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VER"
              PENDING_RELEASE="${PENDING_RELEASE:-none}"
              echo "Read state from dev release: $MAJOR.$MINOR.$PATCH, stage=$STAGE, pre=$PRE_NUMBER, dev=$DEV_NUMBER, pending=$PENDING_RELEASE"
            fi
          else
            # No dev release, check for latest stable release to determine base version
            LATEST_STABLE=$(gh release list --exclude-drafts --exclude-pre-releases --limit 1 --json tagName --jq '.[0].tagName // empty' | sed 's/^v//')
            if [ -n "$LATEST_STABLE" ]; then
              IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_STABLE"
              # Bump for next version
              if [ "$MAJOR" -eq 0 ]; then
                PATCH=$((PATCH + 1))
              else
                MINOR=$((MINOR + 1))
                PATCH=0
              fi
            fi
            echo "Initialized from stable release or defaults: $MAJOR.$MINOR.$PATCH"
          fi

          # If there's a pending release, don't increment dev number (wait for release to complete)
          if [ "$PENDING_RELEASE" != "none" ]; then
            echo "Pending release detected ($PENDING_RELEASE), skipping dev build"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          BASE_VERSION="${MAJOR}.${MINOR}.${PATCH}"

          # Normal dev build - increment dev number
          DEV_NUMBER=$((DEV_NUMBER + 1))
          if [ "$STAGE" = "rtm" ]; then
            VERSION="${BASE_VERSION}-rtm.dev.${DEV_NUMBER}"
          else
            VERSION="${BASE_VERSION}-pre.${PRE_NUMBER}.dev.${DEV_NUMBER}"
          fi

          echo "Dev build: $VERSION"

          # Output version info
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "next_state=${BASE_VERSION}|${STAGE}|${PRE_NUMBER}|${DEV_NUMBER}|none" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

          # Summary
          echo "## Version Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- **Base Version:** ${BASE_VERSION}" >> $GITHUB_STEP_SUMMARY

      - name: Build
        if: steps.version.outputs.skip != 'true'
        uses: ./.github/actions/build
        with:
          version: ${{ steps.version.outputs.version }}

      - name: Test
        if: steps.version.outputs.skip != 'true'
        run: dotnet test test/dotnet-dev-certs-plus.Tests --configuration Release --no-build --verbosity normal --logger "trx;LogFileName=test-results.trx" --logger "html;LogFileName=test-results.html" --results-directory ./test-results

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always() && steps.version.outputs.skip != 'true'
        with:
          name: test-results
          path: |
            ./test-results/*.trx
            ./test-results/*.html
          retention-days: 30

      - name: Publish test results
        uses: dorny/test-reporter@v1
        if: always() && steps.version.outputs.skip != 'true'
        with:
          name: Test Results
          path: ./test-results/*.trx
          reporter: dotnet-trx

      - name: Pack
        if: steps.version.outputs.skip != 'true'
        run: |
          dotnet pack src/dotnet-dev-certs-plus/dotnet-dev-certs-plus.csproj \
            --configuration Release \
            --no-build \
            --output ./artifacts \
            -p:PackageVersion=${{ steps.version.outputs.version }}

      - name: Upload package artifact
        if: steps.version.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: package
          path: ./artifacts/*.nupkg
          retention-days: 90

      - name: Push to GitHub Packages
        if: steps.version.outputs.skip != 'true'
        run: |
          dotnet nuget push ./artifacts/*.nupkg \
            --source "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json" \
            --api-key ${{ secrets.GITHUB_TOKEN }} \
            --skip-duplicate

      - name: Update dev draft release
        if: steps.version.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          NEXT_STATE="${{ steps.version.outputs.next_state }}"

          # Delete existing dev release if exists
          if gh release view dev --json isDraft &>/dev/null; then
            gh release delete dev --yes
          fi

          # Create new dev draft release with state in body
          gh release create dev \
            --draft \
            --prerelease \
            --title "Development Build" \
            --notes "## Development Build

          **Version:** ${VERSION}
          **Commit:** ${{ github.sha }}
          **Build:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          This is an automatically updated pre-release containing the latest development build.

          ### Installation

          \`\`\`bash
          dotnet tool install --global dotnet-dev-certs-plus --version ${VERSION} --add-source https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
          \`\`\`

          <!-- VERSION_STATE: ${NEXT_STATE} -->
          " \
            ./artifacts/*.nupkg
